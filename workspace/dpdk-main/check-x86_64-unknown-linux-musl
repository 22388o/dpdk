#!/usr/bin/env sh
# This file is part of dpdk. It is subject to the license terms in the COPYRIGHT file found in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/dpdk/master/COPYRIGHT. No part of dpdk, including this file, may be copied, modified, propagated, or distributed except according to the terms contained in the COPYRIGHT file.
# Copyright Â© 2016 The developers of dpdk. See the COPYRIGHT file in the top-level directory of this distribution and at https://raw.githubusercontent.com/lemonrock/dpdk/master/COPYRIGHT.


set -e
set -u
set -f


_program_path_find()
{
    if [ "${_program_fattening_program_path+set}" = 'set' ]; then
        printf '%s\n' "$_program_fattening_program_path"

    elif [ "${0%/*}" = "$0" ]; then

        # We've been invoked by the interpreter as, say, bash program
        if [ -r "$0" ]; then
            pwd -P
        # Clutching at straws; probably run via a download, anonymous script, etc, weird execve, etc
        else
            printf '\n'
        fi

    else

        # We've been invoked with a relative or absolute path (also when invoked via PATH in a shell)

        _program_path_find_parentPath()
        {
            parentPath="${scriptPath%/*}"
            if [ -z "$parentPath" ]; then
                parentPath='/'
            fi
            cd "$parentPath" 1>/dev/null
        }

        # pdksh / mksh have problems with unsetting a variable that was never set...
        if [ "${CDPATH+set}" = 'set' ]; then
            unset CDPATH
        fi

        if command -v realpath 1>/dev/null 2>/dev/null; then
            (
                scriptPath="$(realpath "$0")"

                _program_path_find_parentPath
                pwd -P
            )
        elif command -v readlink 1>/dev/null 2>/dev/null; then
            (
                scriptPath="$0"

                while [ -L "$scriptPath" ]
                do
                    _program_path_find_parentPath
                    scriptPath="$(readlink "$scriptPath")"
                done

                _program_path_find_parentPath
                pwd -P
            )
        else
            # This approach will fail in corner cases where the script itself is a symlink in a path not parallel with the concrete script
            (
                scriptPath="$0"

                _program_path_find_parentPath
                pwd -P
            )
        fi

    fi
}

bindgen_wrapper_fail()
{
	local failureMessage="$1"

	printf '%s\n' "$failureMessage" 1>&2
	exit 1
}

bindgen_wrapper_ensureRequiredBinariesArePresent()
{
	local reason="$1"
	shift 1

	local binary
	local missing=false
	for binary in "$@"
	do
		if ! command -v "$binary" 1>/dev/null 2>/dev/null; then
			printf '%s\n' "The binary '$binary' needs to be in the path" 1>&2
			missing=true
		fi
	done

	if $missing; then
		bindgen_wrapper_fail "Please make sure that the missing binaries are installed because '$reason'"
	fi
}

build_runSilentCommand()
{
	set +e
		$@ 1>/dev/null 2>/dev/null
		local exitCode=$?
	set -e

	if [ $exitCode = 0 ]; then
		return
	fi

	bindgen_wrapper_fail "Could not run '$1' - failed with code $exitCode"
}

build_rustup()
{
	if ! command -v rustup 1>/dev/null 2>/dev/null; then
		return 0
	fi

	build_runSilentCommand rustup default "$rustVersion"
	build_runSilentCommand rustup target add "$rustTarget"
}

build_prepare()
{
	if [ ! -e ../dpdk-sys/LICENSE ]; then
		bindgen_wrapper_ensureRequiredBinariesArePresent "To update submodules" git
		git submodule update --init --recursive
	fi

	bindgen_wrapper_ensureRequiredBinariesArePresent "To run rust" rustc cargo

	local platform="$(uname)"
	case "$platform" in

		Darwin)

			bindgen_wrapper_ensureRequiredBinariesArePresent "To check for and, if necessary, install the brew package 'FiloSottile/musl-cross/musl-cross'" brew
			if ! brew list FiloSottile/musl-cross/musl-cross 1>/dev/null 2>/dev/null; then
				brew install FiloSottile/musl-cross/musl-cross
			fi
		;;

	esac

	build_rustup
}

# https://github.com/rust-lang/cargo/issues/3208
build_cargoWorkaround()
{
	if [ ! -e ../dpdk-sys/src/lib.rs ]; then
		printf '' >../dpdk-sys/src/lib.rs
	fi
}

build_main()
{
	local homeFolderPath="$(_program_path_find)"
	cd "$homeFolderPath" 1>/dev/null 2>/dev/null

	# Was nightly-2017-03-16
	local rustVersion='nightly'
	local muslTarget='x86_64-linux-musl'
	local rustTarget='x86_64-unknown-linux-musl'

	build_prepare

	# Also:-
	# HOST_CC=cc (same as CC=cc) and HOST_AR (same as AR)
	# TARGET_CC=cc and TARGET_AR
	# CC_x86_64_unknown_linux_musl="$muslTarget"-cc

	# https://github.com/alexcrichton/gcc-rs

	CROSS_COMPILE="$muslTarget"- \
	CC='cc' \
	AR='cc' \
	RANLIB='cc' \
	HOST_CC='cc' \
	HOST_AR='ar' \
	HOST_RANLIB='ranlib' \
	TARGET_CC="$muslTarget"-cc \
	TARGET_AR="$muslTarget"-ar \
	TARGET_RANLIB="$muslTarget"-ranlib \
	exec cargo check --verbose --target="$rustTarget" "$@"
}

build_main "$@"
